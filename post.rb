# encoding: UTF-8
=begin
Задача 12-3
Наш блокнот не идеален.

У него метод Post.find отвечает как за поиск одного поста, так и за показ всех постов с заданными 
свойствами. Это не очень хорошо.
Перепишите программу так, чтобы в ней было (и использовалось) два метода Post.find_by_id — ищет 
запись с известным номером, а Post.find_all показывает все записи с указанными параметрами.

Всё что вам нужно сделать — разнести код метода Post.find в первой и второй ветвях 
конструкции if-else по разным методам.

Задача 12-4
Добавьте в наш блокнот важное улучшение.
Обработайте случай, когда база по какой-то причине не открылась. Может, просто не найден
 файл или во время записи/чтения произошла ошибка.
Примерный результат обработки исключения (обратите внимание на последние строчки):

Привет, я блокнот версия 2, записываю новые записи в базу SQLite :)
Что хотите записать сегодня?
        0. Memo
        1. Task
        2. Link
1
Что надо сделать?
Купить батон
К какому числу? Укажите дату в формате ДД.ММ.ГГГГ, например 12.05.2003
22.12.2016
Не удалось выполнить запрос в базе notepad.sqlite
no such table: posts
Для искуственного создания ошибки можно, например, удалить файл notepad.sqlite после того, как вы запустили программу, но ещё не создали заметку.
=end

require 'sqlite3'

class Post
  @@SQLITE_DB_FILE = 'notepad.sqlite'# объявляем переменную класса - путь к файлу БД. две @ значит переменная
  # принадлежит всему классу в целом как статический метод 
  
  # Теперь нам нужно будет читать объекты из базы данных
  # поэтому удобнее всегда иметь под рукой связь между классом и его именем в виде строки
  def self.post_types # объявление статического метода класса слово self. post_types - имя метода.
  # этот метод будет возвращать ассоциативный массив детей класса Post. Его переделали в хэш 
  {'Memo' => Memo, 'Task' => Task, 'Link' => Link, 'Tweet' => Tweet}
  end

  def self.create(type) # изменяем параметр на type. Cтатический метод будет создавать экземпляр его дочернего класса
    return post_types[type].new # возвращает из массива post_types созданный новый дочерний класс
  end

  # Статический метод для чтения из БД. Находит в базе запись по идентификатору или массив записей
  # из базы данных, который можно например показать в виде таблицы на экране
  def self.find_by_id(id)
    
      db = SQLite3::Database.open(@@SQLITE_DB_FILE) # открываем "соединение" к базе SQLite
      db.results_as_hash = true # настройка соединения к базе, он результаты из базы преобразует в Руби хэши
      # выполняем наш запрос, он возвращает массив результатов, в нашем случае из одного элемента
    begin # обработка исключения. Обрабатываем команду execute
      result = db.execute("SELECT * FROM posts WHERE  rowid = ?", id) # плейсхолдер ? При обращении в базу
    rescue SQLite3::SQLException => error # ошибка в отсутствии файла БД
      puts "Файл базы данных похоже битый :("
      abort error.message
    end
      # вместо ? будет поставлен id. Метод execute возвращает массив
      # получаем единственный результат (если вернулся массив)
      result = result[0] if result.is_a? Array # если результат массив, то в первом элементе массива
      # будем хранить результат
      db.close # закрываем БД

      if result.empty? # если результат пустой , то ничего не найдено
        puts "Такой id #{id} не найден в базе :("
        return nil
      else # если результат не пустой
        # создаем с помощью нашего же метода create экземпляр поста, и надо его заполнить тем
        # что прочитали из БД
        # тип поста мы взяли из массива результатов [:type]
        # номер этого типа в нашем массиве post_type нашли с помощью метода Array#find_index
        post = create(result['type']) # не пишем Post.create, потому что вызываем статич. метод из 
        # другого статич. метода этого же класса Post

        #   заполним этот пост содержимым
        post.load_data(result) # в качестве параметра метода load_dataберем асс. массив полученный 
        # из БД. Хэш потому что написали ранее  db.results_as_hash = true 

        # и вернем его
        return post
      end

  end

  def self.find_all(limit, type)
    
      db = SQLite3::Database.open(@@SQLITE_DB_FILE) # открываем "соединение" к базе SQLite
      # выведем таблицу записей
      db.results_as_hash = false # настройка соединения к базе, он результаты из базы НЕ преобразует в Руби хэши
      # здесь нам хэш не нужен. Каждый элемент массива будет простым массивом со значениями строки БД
      # формируем запрос в базу с нужными условиями
      query = "SELECT rowid, * FROM posts "
      # далее уточняем этот запрос, если в параметре метода find получили не пустой параметр type, тогда
      # его добавляем в запрос:
      query += "WHERE type = :type " unless type.nil? # если задан тип, надо добавить условие.:type  - это
      # тоже плейсхолдер, но именованный. unless type.nil? - если type не нулевой 
      query += "ORDER by rowid DESC " # и наконец добавляем сортировку по rowid - самые свежие в начале 
      # по убыванию

      # аналогично добавляем параметр limit:
      query += "LIMIT :limit " unless limit.nil? # если задан лимит, надо добавить условие

      # готовим запрос в базу, как плов :)
    begin # обработка исключения. Обрабатываем команду prepare
      statement = db.prepare(query) # передаем в переменную statement объект готовый к 
      # выполнению обработав запрос методом prepare 
      # к этому объекту можно подключать параметры используя именованные плейсхолдеры:
    rescue SQLite3::SQLException => error # ошибка в отсутствии файла БД
      puts "Файл базы данных похоже битый :("
      abort error.message
    end
      statement.bind_param('type', type) unless type.nil? # загружаем в запрос тип вместо плейсхолдера, добавляем лук :)
      # вместо 'type' (именованного плейсхолдера) будет добавлен парметр type
      statement.bind_param('limit', limit) unless limit.nil? # загружаем лимит вместо плейсхолдера, добавляем морковь :)
      # аналогично для limit
    begin # обработка исключения. Обрабатываем команду execute
      result = statement.execute! #(query) # выполняем, чтобы получить результат - массив результатов,
    rescue SQLite3::SQLException => error # ошибка в отсутствии файла БД
      puts "Файл базы данных похоже битый :("
      abort error.message
    end
      # внутри этого массива каждый элемент является массивом содержащим значения всех полей строки БД
      statement.close  # надо закрыть statement
      db.close # закрываем БД

      return result
    
  end
  
   
  def initialize # конструктор класса
    @created_at = Time.now # сразу присвоим полю текущее значение времени
    @text = nil # присвоим полю nil потому что каждый класс-ребенок будет иметь
    # свое значение в этом поле
  end

  def read_from_console # метод запрашивает ввод записей пользователя и
    # записывает его в нужные поля объекта
    #todo будет делать дочерний класс
    # это абстрактный метод, потому что не определен у родителя
  end

  def to_strings # должен возвращать содержимое объекта в виде массива строк
    # готовых к записи в файл
    #todo будет делать дочерний класс
    # это абстрактный метод, потому что не определен у родителя
  end

  def save # метод сохранения мапссива строк to_strings, полученных из
  # метода to_strings, в файл
    file = File.new(file_path, "w:UTF-8") # создали новый файл буд-то мы знаем где он
    #будет находиться. Содержимое этого файла в виде массива строк
    for item in to_strings do
      file.puts(item)
    end
    file.close
  end
  

  def file_path # определяет путь к файлу, куда записывать содержимое
    current_path = File.dirname(__FILE__) # путь к файлу в текущей папке проекта
    file_name = @created_at.strftime("#{self.class.name}_%Y-%m-%d_%H-%M-%S.txt") 
    # преобразовываем к строке. Вначале запишем имя класса, чтобы отличать
    #  self.class.name. %Y-%m-%d_%H-%M-%S - дата создания и время
    # один файл - одна запись
    return current_path + "/" + file_name
  end
# будем делать метод записи в базу данных
  def save_to_db
    db = SQLite3::Database.open(@@SQLITE_DB_FILE) # открываем "соединение" к базе SQLite
    db.results_as_hash = true # настройка соединения к базе, он результаты из базы 
    #преобразует в Руби хэши

    # запрос к базе на вставку новой записи в соответствии с хэшом, сформированным дочерним классом to_db_hash
    begin # обработка исключения
    db.execute(
      "INSERT INTO posts (" +
        to_db_hash.keys.join(', ') + # все поля, перечисленные через запятую
        ") " +
        " VALUES ( " +
        ('?,'*to_db_hash.keys.size).chomp(',') + # строка из заданного числа _плейсхолдеров_ ?,?,?...
        # ? - это плейсхолдер, должны перечисляться через запятую. Их количество равно количеству ключей. 
        #? умноженный на количество ключей отрезаем последний символ запятой chomp(',')
        ")",
      to_db_hash.values # массив значений хэша, которые будут вставлены в запрос вместо _плейсхолдеров_
      # это вторая часть команды db.execute
    )
    rescue SQLite3::SQLException => error # ошибка в отсутствии файла БД
      puts "Файл базы данных похоже битый :("
      abort error.message
    end
     insert_row_id = db.last_insert_row_id # потренируемся и получим идентификатор строки методом last_insert_row_id

    # закрываем соединение с БД как и файлы
    db.close

    # возвращаем идентификатор записи в базе
    return insert_row_id
  end

  def to_db_hash
    # дочерние классы сами знают свое представление, но общие для всех классов поля
    # можно заполнить уже сейчас в базовом классе!
    # метод формирует хэш с названиями полей из БД и их значениями
    {
      # self — ключевое слово, указывает на 'этот объект',
      # то есть конкретный экземпляр класса, где выполняется в данный момент этот код
      'type' => self.class.name,
      'created_at' => @created_at.strftime("%Y.%m.%d %H:%M").to_s # необходимо было добавить
      # метод strftime("%Y.%m.%d %H:%M"), иначе в поле created_at БД записывался непонятный код 
    }
    # todo абстрактный метод, т.к. все поля и их значения каждый экземпляр класса
    # post (дочерние классы) знает
  end

  # Получает на вход хэш массив данных и должен заполнить свои поля
  def load_data(data_hash)
    @created_at = Time.parse(data_hash['created_at'])
    #  todo: остальные специфичные поля должны заполнить дочерние классы
  end

end

# PS: метод self.find получился довольно громоздким и со множеством if — это не хороший стиль.
#
# Подумайте и попробуйте его сделать изящнее и проще.
# Например разбив его на несколько других методов, или переработав его логику (например так,
# чтобы он работал универсальным образом — всегда возвращал массив
# объектов Post. просто в случае с id этот массив будет состоять из одного объекта)
#
# Кстати, подобным "правильным" образом работает похожий метод в Ruby on Rails